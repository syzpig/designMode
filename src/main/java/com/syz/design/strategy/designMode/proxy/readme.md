generalTemplate工程包下面是一个代理模式的通用写法（也是标准的静态代理方法）
但是弊端每次只能代理同一种类型的对对象，或者只能一个类，其他类型的类无法去代理，所以扩展性以及灵活性不够。于是出现动态代理方法。
他针对任何类类型的对象都可以代理（前提是满足jdk 或者cglib动态代理的规则），比如支付：第三方支付，支付宝，微信。他只能每一次代理一个，
我们要生名三个代理对象才可以实现，这样类就会比较膨胀，扩展比较麻烦。使用也不灵活，不能一个代理实现所有业务对象的代理。
JDKproxy工程包是动态代基本实现
JDKproxyLanding工程包是动态代业务落地
Cglibproxy工程包是动态代基本实现
我们可以看到，cglib代理的对象不需要实现任何接口，他是通过动态继承目标对象实现动态代理的
CglibproxyLanding工程包是动态代基本实现


#JDK动态代理与Cglib动态代理区别
1.JDK动态代理实现了，被代理对象的接口，cglib代理继承了代理对象
2.jdk动态代理和Cglib动态代理都是在运行期生成字节码，JDK动态代理直接写Class字节码；CGlib代理使用ASM框架写Class字节码；
CGLib动态代理实现更复杂，生成代理类比jdk动态代理类效率低。
3.JDK动态代理调用代理方法是通过反射机制调用的，CGLib动态代理是通过FastClass机制直接调用的，CGLib代理的执行效率更高。

注：
ASM：是一套java字节码生成架构，它可以动态生成二进制格式的stub类或其它代理类，  
  或者在类被java虚拟机装入内存之前，动态修改类。 
FastClass： Jdk动态代理的拦截对象是通过反射的机制来调用被拦截方法的，反射的效率比较低，所以cglib采用了FastClass的机制来实现对被拦截方法的调用。
  FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法
  
CGLib 有个坑，CGLib不能代理final的方法
  